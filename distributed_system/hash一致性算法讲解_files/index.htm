<!DOCTYPE HTML><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=unicode">
<title>hash一致性算法讲解.md</title>
    
<style id="wiz_custom_css">html, .wiz-editor-body {font-size: 12pt;}.wiz-editor-body {font-family: Helvetica, 'Hiragino Sans GB', '微软雅黑', 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;line-height: 1.7;margin: 0 auto;position:relative;padding: 20px 16px;padding: 1.25rem 1rem;}.wiz-editor-body h1,.wiz-editor-body h2,.wiz-editor-body h3,.wiz-editor-body h4,.wiz-editor-body h5,.wiz-editor-body h6 {margin:20px 0 10px;margin:1.25rem 0 0.625rem;padding: 0;font-weight: bold;}.wiz-editor-body h1 {font-size:20pt;font-size:1.67rem;}.wiz-editor-body h2 {font-size:18pt;font-size:1.5rem;}.wiz-editor-body h3 {font-size:15pt;font-size:1.25rem;}.wiz-editor-body h4 {font-size:14pt;font-size:1.17rem;}.wiz-editor-body h5 {font-size:12pt;font-size:1rem;}.wiz-editor-body h6 {font-size:12pt;font-size:1rem;color: #777777;margin: 1rem 0;}.wiz-editor-body div,.wiz-editor-body p,.wiz-editor-body ul,.wiz-editor-body ol,.wiz-editor-body dl,.wiz-editor-body li {margin:8px 0;}.wiz-editor-body blockquote,.wiz-editor-body table,.wiz-editor-body pre,.wiz-editor-body code {margin:8px 0;}.wiz-editor-body .CodeMirror pre {margin:0;}.wiz-editor-body a {word-wrap: break-word;text-decoration-skip-ink: none;}.wiz-editor-body ul,.wiz-editor-body ol {padding-left:32px;padding-left:2rem;}.wiz-editor-body ol.wiz-list-level1 > li {list-style-type:decimal;}.wiz-editor-body ol.wiz-list-level2 > li {list-style-type:lower-latin;}.wiz-editor-body ol.wiz-list-level3 > li {list-style-type:lower-roman;}.wiz-editor-body li.wiz-list-align-style {list-style-position: inside; margin-left: -1em;}.wiz-editor-body blockquote {padding: 0 12px;}.wiz-editor-body blockquote > :first-child {margin-top:0;}.wiz-editor-body blockquote > :last-child {margin-bottom:0;}.wiz-editor-body img {border:0;max-width:100%;height:auto !important;margin:2px 0;}.wiz-editor-body table {border-collapse:collapse;border:1px solid #bbbbbb;}.wiz-editor-body td,.wiz-editor-body th {padding:4px 8px;border-collapse:collapse;border:1px solid #bbbbbb;min-height:28px;word-break:break-word;box-sizing: border-box;}.wiz-editor-body td > div:first-child {margin-top:0;}.wiz-editor-body td > div:last-child {margin-bottom:0;}.wiz-editor-body img.wiz-svg-image {box-shadow:1px 1px 4px #E8E8E8;}.wiz-hide {display:none !important;}</style><style name="wiz_unsave_style">html, .wiz-editor-body {    font-size: 12pt;}body, .wiz-editor-body {    font-family: Helvetica, 'Hiragino Sans GB', 微软雅黑, 'Microsoft YaHei UI', SimSun, SimHei, arial, sans-serif;    line-height: 1.7; !important;    color: inherit;    background-color: #ffffff;    margin: 0 auto;    padding: 20px 16px;    padding: 1.25rem 1rem;}img{    max-width: 100%;}.wiz-todo-main{	line-height: 1.7; !important;}</style><style name="wiz_unsave_style">body::-webkit-scrollbar {width: 16px;height: 16px;background-color: #f0f0f0;border: none;}body::-webkit-scrollbar-thumb {background-color: #dcdcdc;}body::-webkit-scrollbar-thumb:hover {background-color: #c0c0c0;}body::-webkit-scrollbar-thumb:active {background-color: #969696;}body::-webkit-scrollbar-thumb:disabled {background-color: #f9f9f9;}body::_webkit_scrollbar-track {background-color: #ffffff;}body::-webkit-scrollbar-corner {background-color: #f0f0f0;}body::-webkit-scrollbar-button {\*  display: none;*\}body.flat-scrollbar::-webkit-scrollbar,body.flat-scrollbar div::-webkit-scrollbar,body.flat-scrollbar ul::-webkit-scrollbar,body.flat-scrollbar aside::-webkit-scrollbar,body.flat-scrollbar iframe::-webkit-scrollbar {width: 12px;height: 12px;}</style><script type="text/javascript" src="file:///D:/Program%20Files/WizNote/WizTools/htmleditor/editorHelper.js" wiz_style="unsave" charset="utf-8" defer></script><script type="text/javascript" src="file:///D:/Program%20Files/weizhinotestroge/templates/WizTemplate.js" wiz_style="unsave" charset="utf-8" defer></script><script type="text/javascript" src="file:///D:/Program%20Files/WizNote/WizTools/htmleditor/core/wizEditorForPc.js" wiz_style="unsave" charset="utf-8" defer></script><script type="text/javascript" wiz_style="unsave" charset="utf-8">document.addEventListener('DOMContentLoaded', function handler(){
	if(window.external){
		try{
			window.WizChromeBrowser.Execute("Wiz_DOMContentLoaded", null, null, null, null);
		}catch(err){
			console.err(err);
		}
	}
	document.removeEventListener('DOMContentLoaded', handler, false);
}, false);</script></head>

<body class="wiz-editor-body" spellcheck="false" ><div style="font-size:0.875rem"><span style="font-size: 1.5rem; color: rgb(34, 34, 34);">概述</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">一致Hash在分布式应用中,是常见的负载均衡方式,多用于资源请求映射分散到具体某一台节点服务器,使得每一台服务器能固定处理部分请求,同时,能较小的减少由于动态增减服务器节点带来请求的失效，保证系统更好对外提供服务。</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);"><br></span></div><div style="font-size:0.875rem"><span style="font-size: 1.5rem; color: rgb(34, 34, 34);">从问题的发展引入思考</span></div><div style="font-size:0.875rem"><img alt="" data-media-type="image" src="" style="" data-attr-org-src-id="10D3F2B518404FB7AB5FBC464D1CEE68"></div><div style="font-size: 0.875rem; text-align: center;"><img src="index_files/ConsistentHashing1.jpg" style="vertical-align: bottom; max-width: 100%;"></div><div style="font-size: 0.875rem; text-align: center;"><span style="color: rgb(153, 153, 153); font-size: 0.75rem;">图1.假设现在有200万张图片资源，需要随机的分配到3台服务器</span></div><div style="font-size:0.875rem"><span style="font-size: 1.5rem; color: rgb(34, 34, 34);">除余法</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">很多人一下子就想到了除余法,通过给每个图片唯一编号(较少的情况),或者通过hash文件名(假设文件名不重复)得到唯一的数字串,然后除余就能随机存放到服务器。</span></div><div style="font-size:0.875rem"><span style="font-size:1rem;font-family:monospace;color:rgb(153, 153, 153);background-color:rgb(244, 245, 246);">hash(文件名) % n</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">正常情况下这个算法已经基本满足,因为每次除余之后必然会得到0,1,2三个数,分别对应三台服务器,下次需要找回这些图片资源只要按同样的方式hash之后就能在对应服务器找到。</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">但是当图片资源过多无法满足需要增加一台服务器的时候,因为除数的改变,带来余数的改变,</span><span style="font-size: 1rem; color: rgb(168, 46, 46);">也就是服务器数量的改变,带来存储位置的改变</span><span style="font-size: 1rem; color: rgb(34, 34, 34);">,之前存储的图片资源失去了意义,在缓存服务器中,这会导致大量缓存失效,造成缓存的雪崩,为了解决这些问题,一致性hash应运而生。</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);"><br></span></div><div style="font-size:0.875rem"><span style="font-size: 1.5rem; color: rgb(34, 34, 34);">揭开一致性Hash神秘面纱</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">首先了解一下计算一致性hash时采用的方式和步骤：</span></div><div style="font-size:0.875rem"><ol class="wiz-list-level1"><li style="font-size:1rem;font-family:&quot;Microsoft YaHei&quot;, STXihei;color:rgb(34, 34, 34);text-decoration:none;"><span style="">在一个0~2^32区间的圆环上，计算服务器节点的hash值,。</span></li><li style="font-size:1rem;font-family:&quot;Microsoft YaHei&quot;, STXihei;color:rgb(34, 34, 34);text-decoration:none;"><span style="">用同样的方式计算存储数据的hash,并映射到相同的圆上。</span></li><li style="font-size:1rem;font-family:&quot;Microsoft YaHei&quot;, STXihei;color:rgb(34, 34, 34);text-decoration:none;"><span style="">然后从数据映射到的位置开始顺时针查找，那么在圆上必然能映射到具体一台节点服务器。</span></li></ol></div><div style="font-size:0.875rem"><img alt="" data-media-type="image" src="" style="" data-attr-org-src-id="C82564A61A0B40C0A08F84B2FA5397C3"></div><div style="font-size:0.875rem;text-align:center"><img src="index_files/ConsistentHashing2.jpg" style="vertical-align: bottom; max-width: 100%;"></div><div style="font-size: 0.875rem; text-align: center;"><span style="font-size: 0.75rem; color: rgb(153, 153, 153);">图2.一致hash算法映射到圆环</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">这里解释一下,一致性Hash也是采用取模的方法,其hash计算的区间同样是在0~2^32,这算法很多语言都有,比如go语言的crc32.ChecksumIEEE就有实现此算法,那么这个一致性hash有什么优势呢?</span></div><div style="font-size:0.875rem"><img alt="" data-media-type="image" src="" style="" data-attr-org-src-id="90ABCCEDFCC44241AA98E31693B37ECD"></div><div style="font-size:0.875rem;text-align:center"><img src="index_files/ConsistentHashing3.jpg" style="vertical-align: bottom; max-width: 100%;"></div><div style="font-size: 0.875rem; text-align: center;"><span style="font-size: 0.75rem; color: rgb(153, 153, 153);">图3.NodeB宕机/摘除的情况(虚线圆)</span></div><div style="font-size:0.875rem;text-align:center"><img src="index_files/ConsistentHashing4.jpg" style="vertical-align: bottom; max-width: 100%;"></div><div style="font-size: 0.875rem; text-align: center;"><span style="font-size: 0.75rem; color: rgb(153, 153, 153);">图4.新增一个节点的情况</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">如图3.在NodeB宕机或摘除节点之后,存储数据对象ObjectB按照顺时针原则重新映射到NodeC服务器节点。</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">如图4.在新增节点NodeD之后，存储数据对象ObjectB同样映射到了NodeD服务器节点，但是新增和摘除节点都没有影响到ObjectA和ObjectC,这就使得这种一致hash算法在增减节点时候并不会导致大面积请求资源的失效。</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">并且随着服务器节点的增加，影响会越来越小。但是理想很丰满,现实却很骨感,当服务节点比较少的情况下,其实并不是如图3,图4这样分配均匀的，而是有可能出现数据倾斜的,下面拿摘除NodeA做举例：</span></div><div style="font-size:0.875rem"><br></div><div style="font-size:0.875rem;text-align:center"><img src="index_files/ConsistentHashing5.jpg" style="vertical-align: bottom; max-width: 100%;"></div><div style="font-size: 0.875rem; text-align: center;"><span style="font-size: 0.75rem; color: rgb(153, 153, 153);">图5.一致hash可能出现数据倾斜的情况</span></div><div style="font-size:0.875rem"><br></div><div style="font-size:0.875rem;text-align:center"><img src="index_files/ConsistentHashing6.jpg" style="vertical-align: bottom; max-width: 100%;"></div><div style="font-size: 0.875rem; text-align: center;"><span style="font-size: 0.75rem; color: rgb(153, 153, 153);">图6.NodeA宕机/摘除,大量存储数据映射到了NodeB</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">如图5、6不难看出，当服务器较少并且数据出现一定倾斜的时候,假设NodeA出现宕机,这时候资源请求会重新映射到NodeB,那么NodeB机器的压力就会暴涨,在硬件资源有限的情况下,又怎么更好的处理这个问题呢？</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);"><br></span></div><div style="font-size:0.875rem"><span style="font-size: 1.5rem; color: rgb(34, 34, 34);">虚拟节点</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">上面提到的过程基本上就是一致性hash的基本原理了,不过还有一个问题就是当服务器节点较少的时候,如何解决这个负载不均衡的问题，那就是虚拟节点。</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">其实就是将每台物理机器,映射成n多个虚拟机器,再将这些虚拟机器hash之后映射到圆环上。</span></div><div style="font-size:0.875rem;text-align:center"><img src="index_files/ConsistentHashing7.jpg" style="vertical-align: bottom; max-width: 100%;"></div><div style="font-size: 0.875rem; text-align: center;"><span style="font-size: 0.75rem; color: rgb(153, 153, 153);">图7.虚拟机器和物理机器的映射</span></div><div style="font-size:0.875rem"><br></div><div style="font-size:0.875rem;text-align:center"><img src="index_files/ConsistentHashing8.jpg" style="vertical-align: bottom; max-width: 100%;"></div><div style="font-size: 0.875rem; text-align: center;"><span style="font-size: 0.75rem; color: rgb(153, 153, 153);">图8.生成多个虚拟节点进行映射，图中省略了hash过程</span></div><div style="font-size: 0.875rem; text-align: center;"><span style="font-size: 0.75rem; color: rgb(153, 153, 153);"><br></span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">数据定位到圆环算法是不变的，只是多了一步虚拟节点到实际节点的映射。</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">你品,你细品一下!!</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);"><br></span></div><div style="font-size:0.875rem"><span style="font-size: 1.5rem; color: rgb(34, 34, 34);">最后,表述一下在动态变化的Cache环境中，判定哈希算法好坏的四个定义：</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">1、</span><span style="font-size: 1rem; color: rgb(168, 46, 46);">平衡性(Balance)</span><span style="font-size: 1rem; color: rgb(34, 34, 34);">：平衡性是指哈希的结果能够尽可能分布到所有的缓冲中去，这样可以使得所有的缓冲空间都得到利用。很多哈希算法都能够满足这一条件。</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">2、</span><span style="font-size: 1rem; color: rgb(168, 46, 46);">单调性(Monotonicity)</span><span style="font-size: 1rem; color: rgb(34, 34, 34);">：单调性是指如果已经有一些内容通过哈希分派到了相应的缓冲中，又有新的缓冲加入到系统中。哈希的结果应能够保证原有已分配的内容可以被映射到原有的或者新的缓冲中去，而不会被映射到旧的缓冲集合中的其他缓冲区。</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">3、</span><span style="font-size: 1rem; color: rgb(168, 46, 46);">分散性(Spread)</span><span style="font-size: 1rem; color: rgb(34, 34, 34);">：在分布式环境中，终端有可能看不到所有的缓冲，而是只能看到其中的一部分。当终端希望通过哈希过程将内容映射到缓冲上时，由于不同终端所见的缓冲范围有可能不同，从而导致哈希的结果不一致，最终的结果是相同的内容被不同的终端映射到不同的缓冲区中。这种情况显然是应该避免的，因为它导致相同内容被存储到不同缓冲中去，降低了系统存储的效率。分散性的定义就是上述情况发生的严重程度。好的哈希算法应能够尽量避免不一致的情况发生，也就是尽量降低分散性。</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">4、</span><span style="font-size: 1rem; color: rgb(168, 46, 46);">负载(Load)</span><span style="font-size: 1rem; color: rgb(34, 34, 34);">：负载问题实际上是从另一个角度看待分散性问题。既然不同的终端可能将相同的内容映射到不同的缓冲区中，那么对于一个特定的缓冲区而言，也可能被不同的用户映射为不同 的内容。与分散性一样，这种情况也是应当避免的，因此好的哈希算法应能够尽量降低缓冲的负荷。</span></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">4、</span><span style="font-size: 1rem; color: rgb(168, 46, 46);">平滑性(Smoothness)</span><span style="font-size: 1rem; color: rgb(34, 34, 34);">：平滑性是指缓存服务器的数目平滑改变和缓存对象的平滑改变是一致的。</span></div><div style="font-size:0.875rem"><br></div><div style="font-size:0.875rem"><span style="font-size: 1rem; color: rgb(34, 34, 34);">下节课将给童鞋们讲解一下一致hash算法的代码实现,喜欢童鞋可以关注一哈</span></div><div style="font-size:0.875rem;"><br></div></body></html>