## 主从复制过程
复制的过程大致分为6个过程：
 1. **保存主节点信息。**
 执行slaveof后从节点会保存主节点的ip和port等信息,这时建立的复制还没开始,与主节点的连接状态master_link_status是下线状态。
 
 2. **主从建立socket连接**
 从节点内部通过每秒运行的定时任务维护复制相关逻辑，当定时任务发现存在新的主节点后，会尝试与该节点建立网络连接。
 如果从节点无法建立连接，定时任务会无限重试知道连接成功或者执行slaveof no one取消复制。
 3. **发送ping命令** 
 连接建立成功后从节点发送ping请求进行首次通信，ping请求主要目的如下：
 	 - 检查主从之间网络套接字是否可用。
 	 - 检查主节点当前是否可接受处理命令。
 4. **权限验证**
 如果主节点设置了requirepass参数,则需要密码验证,从节点必须配置masterauth参数保证与主节点相同的密码才能通过验证;如果验证失败复制将终止，从节点重新发起复制流程。
 5. **同步数据集**
 对于首次建立复制的场景,主节点会把持有的数据全部发送给从节点，这部分操作是耗时最长的步骤。Redis在2.8版本之后采用新命令**psync**进行数据同步，新版的同步分为全量同步和部分同步。
6. **命令的持续复制。**
当主节点把当前的数据同步给从节点后，便完成了复制的建立流程。接下来主节点会持续把写命令发送给从节点，保证数据的一致性。

## psync
psync是对主从复制过程第五点进行重点的讲解一下：
Redis2.8及以上版本使用psync命令完成主从数据同步，同步过程分为：全量复制和部分复制。
 - 全量复制：一般用于初次复制场景，Redis早期支持的复制功能只有全量复制，它会把主节点全部数据一次性发送给从节点，当数据量比较大的时候，会对主从节点和网络造成很大开销。
 - 部分复制：用于处理主从复制中因网络闪断等原因造成的数据丢失场景，当从节点再次连上主节点后，如果条件允许，主节点会补发丢失数据给从节点，因为补发的数据远远小于全量数据，可以有效避免全量复制的过高开销。

**psync命令运行需要一下组件支持：**
  - 主从节点各自复制偏移量。
 - 主节点复制积压缓冲区。
 - 主节点运行id

1. **复制偏移量**
参与复制的主从节点都会维护自身复制的偏移量。主节点(master)在处理完写入命令后，会把命令的字节长度做累加记录。
从节点每秒上报自身的复制偏移量给主节点，因此主节点也会保存从节点的复制偏移量。
从节点在接收到主节点的命令后，也会累加记录自身的偏移量。
	通过对比主从节点的复制偏移量，可以判断主从节点数据是否一致。
	如果主从之间复制偏移量相差较大，则可能通过网络延迟或命令阻塞等原因引起。
	
2. **复制积压缓存区**
复制积压缓存区是保存在主节点上的一个固定长度的队列，默认大小为1MB,当主节点有连接的从节点（slave）时被创建，这时主节点（master）响应写命令时，不但会把命令发送给从节点，还会写入复制积压缓存区。

缓冲区本质上是先进先出的定长队列，所以能保存最近已复制的数据功能，用于部分复制和复制命令丢失的数据补救。(这里是否只是做补救而已)

 3. **主节点运行ID**
 每个Redis节点启动之后都会分配一个40位的十六进制字符串作为运行ID。运行ID的作用是用来唯一识别Redis节点，比如从节点保存主节点的运行ID识别自己正在复制的是哪个主节点。
	可以info server命令查看当前节点的运行ID:info server
	需要注意的是Redis关闭再启动后，运行ID会随之改变。

### psync流程
**从节点**使用psync命令完成部分复制和全量复制,命令格式如下:psync{runId}{offset},参数含义如下：
 - runId： 从节点所复制主节点的运行id。
 - offset： 当前从节点已复制的数据偏移量。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200404120420278.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NzMxMDU2,size_16,color_FFFFFF,t_70)
流程说明：
 - 从节点（slave） 发送psync命令给主节点， 参数runId是当前从节点保存的主节点运行ID， 如果没有则默认值为， 参数offset是当前从节点保存的复制偏移量， **如果是第一次参与复制则默认值为-1。**
 - 主节点（master） 根据psync参数和自身数据情况决定响应结果：
 - 如果回复+FULLRESYNC{runId}{offset}， 那么从节点将触发全量复制流程。
 - 如果回复+CONTINUE， 从节点将触发部分复制流程。
 - 如果回复+ERR， 说明主节点版本低于Redis2.8， 无法识别psync命令，从节点将发送旧版的sync命令触发全量复制流程。

#### 全量复制
全量复制是Redis最早支持的复制方式， 也是主从第一次建立复制时必须经历的阶段。 触发全量复制的命令是sync和psync， 它们的对应版本如图:
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200403104155903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NzMxMDU2,size_16,color_FFFFFF,t_70)
全量复制的流程：
![在这里插入图片描述](https://img-blog.csdnimg.cn/2020040310443129.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NzMxMDU2,size_16,color_FFFFFF,t_70)
 1. 发送psync命令进行数据同步， 由于是第一次进行复制， 从节点没有复制偏移量和主节点的运行ID， 所以发送psync-1。
 2. 主节点根据psync-1解析出当前为全量复制， 回复+FULLRESYNC响应。
 3. 从节点接收主节点的响应数据保存运行ID和偏移量offset
 4. 主节点执行bgsave保存RDB文件到本地
 5. 主节点发送RDB文件给从节点，从节点把接收的RDB文件保存在本地并直接作为从节点的数据文件。
注意，对于数据量较大的主节点，比如生成的RDB文件超过6GB以上时要格外小心。传输文件这一部操作非常耗时，速度取决于主从节点之间网络带宽，通过细致分析Full resync和MASTER<->SLAVE这两行日志的时间差，可以算出RDB文件从创建到传输完毕消耗的总时间。如果总时间超过repl-timeout所配置的值(默认60秒),从节点将放弃接收RDB文件并清理已经下载的临时文件，导致全量复制失败。

	针对数据量较大的节点， 建议调大repl-timeout参数防止出现全量同步数据超时。 例如对于千兆网卡的机器， 网卡带宽理论峰值大约每秒传输100MB， 在不考虑其他进程消耗带宽的情况下， 6GB的RDB文件至少需要60秒传输时间， 默认配置下， 极易出现主从数据同步超时。
	
	关于无盘复制： 为了降低主节点磁盘开销， Redis支持无盘复制， 生成的RDB文件不保存到硬盘而是直接通过网络发送给从节点， 通过repldiskless-sync参数控制， 默认关闭。 无盘复制适用于主节点所在机器磁盘性能较差但网络带宽较充裕的场景。 注意无盘复制目前依然处于试验阶段，线上使用需要做好充分测试。
 6. 对于从节点开始接收RDB快照到接收完成期间， 主节点仍然响应读写命令， 因此主节点会把这期间写命令数据保存在复制客户端缓冲区内， 当从节点加载完RDB文件后， 主节点再把缓冲区内的数据发送给从节点， 保证主从之间数据一致性。 如果主节点创建和传输RDB的时间过长， 对于高流量写入场景非常容易造成主节点复制客户端缓冲区溢出。 默认配置为clientoutput-buffer-limit slave256MB64MB60， 如果60秒内缓冲区消耗持续大于64MB或者直接超过256MB时， 主节点将直接关闭复制客户端连接， 造成全量同步失败。 

	因此， 运维人员需要根据主节点数据量和写命令并发量调整clientoutput-buffer-limit slave配置， 避免全量复制期间客户端缓冲区溢出。
 7. 从节点接收完主节点传送来的全部数据后会清空自身旧数据
 8. 从节点清空数据后开始加载RDB文件， 对于较大的RDB文件， 这一步操作依然比较耗时。
	对于线上做读写分离的场景， 从节点也负责响应读命令。 如果此时从节点正出于全量复制阶段或者复制中断， 那么从节点在响应读命令可能拿到过期或错误的数据。 对于这种场景， Redis复制提供了slave-serve-stale-data参数， 默认开启状态。 如果开启则从节点依然响应所有命令。 对于无法容忍不一致的应用场景可以设置no来关闭命令执行， 此时从节点除了info和slaveof命令之外所有的命令只返回“SYNC with master in progress”信息。
 9. 从节点成功加载完RDB后， 如果当前节点开启了AOF持久化功能，它会立刻做bgrewriteaof操作， 为了保证全量复制后AOF持久化文件立刻可用。
 
 通过分析全量复制的所有流程， 读者会发现**全量复制是一个非常耗时费力的操作**。 它的时间开销主要包括： 
 10. 主节点bgsave时间。
 11. RDB文件网络传输时间。
 12. 从节点清空数据时间。
 13. 从节点加载RDB的时间。
 14. 可能的AOF重写时间。

#### 部分复制
	部分复制主要是Redis针对全量复制的过高开销做出的一种优化措施，使用psync{runId}{offset}命令实现。 当从节点（slave） 正在复制主节点（master） 时， 如果出现网络闪断或者命令丢失等异常情况时， 从节点会向主节点要求补发丢失的命令数据， 如果主节点的复制积压缓冲区内存在这部分数据则直接发送给从节点， 这样就可以保持主从节点复制的一致性。 补发的这部分数据一般远远小于全量数据， 所以开销很小。
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200403110211982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NzMxMDU2,size_16,color_FFFFFF,t_70)
流程说明：
 1. 当主从节点之间网络出现中断时， 如果超过repl-timeout时间， 主节点会认为从节点故障并中断复制连接。
 2. 主从连接中断期间主节点依然响应命令， 但因复制连接中断命令无法发送给从节点， 不过主节点内部存在的复制积压缓冲区， 依然可以保存最近一段时间的写命令数据， 默认最大缓存1MB。
 	积压缓存区是在什么时候存在的？
 3. 当主从节点网络恢复后， 从节点会再次连上主节点。
 4. 当主从连接恢复后， 由于从节点之前保存了自身已复制的偏移量和主节点的运行ID。 因此会把它们当作psync参数发送给主节点， 要求进行部分复制操作。 
 5. 节点接到psync命令后首先核对参数runId是否与自身一致， 如果一致， 说明之前复制的是当前主节点； 之后根据参数offset在自身复制积压缓冲区查找， 如果偏移量之后的数据存在缓冲区中， 则对从节点发送+CONTINUE响应， 表示可以进行部分复制。
 6. 主节点根据偏移量把复制积压缓冲区里的数据发送给从节点， 保证主从复制进入正常状态。 

#### 心跳
主从节点在建立复制后， 它们之间维护着长连接并彼此发送心跳命令
![在这里插入图片描述](https://img-blog.csdnimg.cn/20200403131656958.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzM3NzMxMDU2,size_16,color_FFFFFF,t_70)
主从心跳判断机制：
 1. 主从节点彼此都有心跳检测机制， 各自模拟成对方的客户端进行通信， 通过client list命令查看复制相关客户端信息， 主节点的连接状态为flags=M， 从节点连接状态为flags=S。
 2. 主节点默认每隔10秒对从节点发送ping命令， 判断从节点的存活性和连接状态。 可通过参数repl-ping-slave-period控制发送频率。
 3. 从节点在主线程中每隔1秒发送replconf ack{offset}命令， 给主节点上报自身当前的复制偏移量。replconf命令主要作用如下：
 - 实时监测主从节点网络状态。
 - 上报自身复制偏移量， 检查复制数据是否丢失， 如果从节点数据丢失， 再从主节点的复制缓冲区中拉取丢失数据。
 - 实现保证从节点的数量和延迟性功能， 通过min-slaves-to-write、 minslaves-max-lag参数配置定义。
 
 主节点根据replconf命令判断从节点超时时间， 体现在info replication统计中的lag信息中， lag表示与从节点最后一次通信延迟的秒数， 正常延迟应该在0和1之间。 如果超过repl-timeout配置的值（默认60秒） ， 则判定从节点下线并断开复制客户端连接。 即使主节点判定从节点下线后， 如果从节点重
新恢复， 心跳检测会继续进行。

## 异步复制
主节点不但负责数据读写， 还负责把写命令同步给从节点。 写命令的发送过程是异步完成， 也就是说主节点自身处理完写命令后直接返回给客户端， 并不等待从节点复制完成

主节点复制流程：
 1. 主节点6379接收处理命令。
 2. 命令处理完之后返回响应结果。
 3. 对于修改命令异步发送给6380从节点， 从节点在主线程中执行复制的命令。
 
 由于主从复制过程是异步的， 就会造成从节点的数据相对主节点存在延迟。 具体延迟多少字节， 我们可以在主节点执行info replication命令查看相关指标获得。
在统计信息中可以看到从节点slave0信息，分别记录了从节点的ip和 port，从节点的状态，offset表示当前从节点的复制偏移量， master_repl_offset表示当前主节点的复制偏移量，两者的差值就是当前从节 点复制延迟量。Redis的复制速度取决于主从之间网络环境，repl-disable- tcp-nodelay，命令处理速度等。正常情况下，延迟在1秒以内。

